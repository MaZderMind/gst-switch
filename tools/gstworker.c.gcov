        -:    0:Source:gstworker.c
        -:    0:Programs:7
        -:    1:/* GstSwitchSrv
        -:    2: * Copyright (C) 2012 Duzy Chan <code@duzy.info>
        -:    3: *
        -:    4: * Redistribution and use in source and binary forms, with or without
        -:    5: * modification, are permitted provided that the following conditions
        -:    6: * are met:
        -:    7: * 1. Redistributions of source code must retain the above copyright
        -:    8: *    notice, this list of conditions and the following disclaimer.
        -:    9: * 2. Redistributions in binary form must reproduce the above copyright
        -:   10: *    notice, this list of conditions and the following disclaimer in the
        -:   11: *    documentation and/or other materials provided with the distribution.
        -:   12: *
        -:   13: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
        -:   14: * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   15: * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   16: * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
        -:   17: * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   18: * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
        -:   19: * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   20: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
        -:   21: * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
        -:   22: * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        -:   23: * POSSIBILITY OF SUCH DAMAGE.
        -:   24: */
        -:   25:
        -:   26:/*! @file */
        -:   27:
        -:   28:#ifdef HAVE_CONFIG_H
        -:   29:#include "config.h"
        -:   30:#endif
        -:   31:
        -:   32:#include "gstworker.h"
        -:   33:#include "gstswitchserver.h"
        -:   34:
        -:   35:#define GST_WORKER_LOCK_PIPELINE(srv) (g_mutex_lock (&(srv)->pipeline_lock))
        -:   36:#define GST_WORKER_UNLOCK_PIPELINE(srv) (g_mutex_unlock (&(srv)->pipeline_lock))
        -:   37:
        -:   38:enum
        -:   39:{
        -:   40:  PROP_0,
        -:   41:  PROP_NAME,
        -:   42:};
        -:   43:
        -:   44:enum
        -:   45:{
        -:   46:  SIGNAL_PREPARE_WORKER,
        -:   47:  SIGNAL_START_WORKER,
        -:   48:  SIGNAL_END_WORKER,
        -:   49:  SIGNAL_WORKER_NULL,
        -:   50:  SIGNAL__LAST,                 /*!< @internal */
        -:   51:};
        -:   52:
        -:   53:/*!< @internal */
        -:   54:static guint gst_worker_signals[SIGNAL__LAST] = { 0 };
        -:   55:
        -:   56:extern gboolean verbose;
        -:   57:
        -:   58:#if ENABLE_ASSESSMENT
        -:   59:guint assess_number = 0;
        -:   60:#endif //ENABLE_ASSESSMENT
        -:   61:
        -:   62:/*!< @internal */
        -:   63:#define gst_worker_parent_class parent_class
        -:   64:
        -:   65:/*!< @internal */
    #####:   66:G_DEFINE_TYPE (GstWorker, gst_worker, G_TYPE_OBJECT);
        -:   67:
        -:   68:/**
        -:   69: * @brief Initialize GstWorker instances.
        -:   70: * @param worker The GstWorker instance.
        -:   71: * @memberof GstWorker
        -:   72: */
        -:   73:static void
    #####:   74:gst_worker_init (GstWorker * worker)
        -:   75:{
    #####:   76:  worker->name = NULL;
        -:   77:  //worker->server = NULL;
    #####:   78:  worker->bus = NULL;
    #####:   79:  worker->pipeline = NULL;
    #####:   80:  worker->pipeline_func = NULL;
    #####:   81:  worker->pipeline_func_data = NULL;
    #####:   82:  worker->pipeline_string = NULL;
    #####:   83:  worker->paused_for_buffering = FALSE;
    #####:   84:  worker->watch = 0;
        -:   85:
    #####:   86:  g_mutex_init (&worker->pipeline_lock);
        -:   87:
        -:   88:  //INFO ("gst_worker init %p", worker);
    #####:   89:}
        -:   90:
        -:   91:/**
        -:   92: * @brief Free GstWorker instances.
        -:   93: * @param worker The GstWorker instance.
        -:   94: * @memberof GstWorker
        -:   95: */
        -:   96:static void
    #####:   97:gst_worker_dispose (GstWorker * worker)
        -:   98:{
        -:   99:  //INFO ("gst_worker dispose %p", worker);
    #####:  100:  if (worker->pipeline) {
    #####:  101:    gst_element_set_state (worker->pipeline, GST_STATE_NULL);
        -:  102:  }
    #####:  103:  if (worker->bus) {
    #####:  104:    gst_bus_set_flushing (worker->bus, TRUE);
        -:  105:  }
        -:  106:
    #####:  107:  G_OBJECT_CLASS (parent_class)->dispose (G_OBJECT (worker));
    #####:  108:}
        -:  109:
        -:  110:/**
        -:  111: * @brief Destroy GstWorker instances.
        -:  112: * @param worker The GstWorker instance.
        -:  113: * @memberof GstWorker
        -:  114: */
        -:  115:static void
    #####:  116:gst_worker_finalize (GstWorker * worker)
        -:  117:{
    #####:  118:  if (worker->watch) {
    #####:  119:    g_source_remove (worker->watch);
    #####:  120:    worker->watch = 0;
        -:  121:  }
    #####:  122:  if (worker->pipeline) {
    #####:  123:    INFO ("pipeline ref %d", GST_OBJECT_REFCOUNT (worker->pipeline));
    #####:  124:    gst_object_unref (worker->pipeline);
    #####:  125:    worker->pipeline = NULL;
        -:  126:  }
    #####:  127:  if (worker->bus) {
    #####:  128:    INFO ("bus ref %d", GST_OBJECT_REFCOUNT (worker->bus));
    #####:  129:    gst_object_unref (worker->bus);
    #####:  130:    worker->bus = NULL;
        -:  131:  }
        -:  132:
        -:  133:  /*
        -:  134:     if (worker->server) {
        -:  135:     g_object_unref (worker->server);
        -:  136:     worker->server = NULL;
        -:  137:     }
        -:  138:   */
        -:  139:
    #####:  140:  if (worker->pipeline_string) {
    #####:  141:    g_string_free (worker->pipeline_string, TRUE);
    #####:  142:    worker->pipeline_string = NULL;
        -:  143:  }
        -:  144:
        -:  145:
    #####:  146:  INFO ("gst_worker finalize %p", worker);
    #####:  147:  g_mutex_clear (&worker->pipeline_lock);
        -:  148:
    #####:  149:  g_free (worker->name);
    #####:  150:  worker->name = NULL;
        -:  151:
    #####:  152:  if (G_OBJECT_CLASS (parent_class)->finalize)
    #####:  153:    (*G_OBJECT_CLASS (parent_class)->finalize) (G_OBJECT (worker));
    #####:  154:}
        -:  155:
        -:  156:/**
        -:  157: * @brief Set GstWorker properties.
        -:  158: * @param worker The GstWorker instance.
        -:  159: * @param property_id
        -:  160: * @param value
        -:  161: * @param pspec
        -:  162: * @memberof GstWorker
        -:  163: */
        -:  164:static void
    #####:  165:gst_worker_set_property (GstWorker * worker, guint property_id,
        -:  166:    const GValue * value, GParamSpec * pspec)
        -:  167:{
    #####:  168:  switch (property_id) {
        -:  169:    case PROP_NAME:
        -:  170:    {
    #####:  171:      if (worker->name)
    #####:  172:        g_free (worker->name);
    #####:  173:      worker->name = g_strdup (g_value_get_string (value));
    #####:  174:      break;
        -:  175:    }
        -:  176:    default:
    #####:  177:      G_OBJECT_WARN_INVALID_PROPERTY_ID (G_OBJECT (worker), property_id, pspec);
    #####:  178:      break;
        -:  179:  }
    #####:  180:}
        -:  181:
        -:  182:/**
        -:  183: * @brief Get GstWorker properties.
        -:  184: * @param worker The GstWorker instance.
        -:  185: * @param property_id
        -:  186: * @param value
        -:  187: * @param pspec
        -:  188: * @memberof GstWorker
        -:  189: */
        -:  190:static void
    #####:  191:gst_worker_get_property (GstWorker * worker, guint property_id,
        -:  192:    GValue * value, GParamSpec * pspec)
        -:  193:{
    #####:  194:  switch (property_id) {
        -:  195:    case PROP_NAME:
        -:  196:    {
    #####:  197:      g_value_set_string (value, worker->name);
    #####:  198:      break;
        -:  199:    }
        -:  200:    default:
    #####:  201:      G_OBJECT_WARN_INVALID_PROPERTY_ID (G_OBJECT (worker), property_id, pspec);
    #####:  202:      break;
        -:  203:  }
    #####:  204:}
        -:  205:
        -:  206:/**
        -:  207: * @brief Get GstWorker pipeline string.
        -:  208: * @param worker The GstWorker instance.
        -:  209: * @memberof GstWorker
        -:  210: */
        -:  211:static GString *
    #####:  212:gst_worker_get_pipeline_string (GstWorker * worker)
        -:  213:{
    #####:  214:  GString *desc = NULL;
    #####:  215:  if (worker->pipeline_func)
    #####:  216:    desc = worker->pipeline_func (worker, worker->pipeline_func_data);
    #####:  217:  if (!desc && worker->pipeline_string)
    #####:  218:    desc = g_string_new (worker->pipeline_string->str);
    #####:  219:  if (!desc)
    #####:  220:    desc = g_string_new ("");
    #####:  221:  return desc;
        -:  222:}
        -:  223:
        -:  224:/**
        -:  225: * @brief Create GstWorker pipeline.
        -:  226: * @param worker The GstWorker instance.
        -:  227: * @memberof GstWorker
        -:  228: */
        -:  229:static GstElement *
    #####:  230:gst_worker_create_pipeline (GstWorker * worker)
        -:  231:{
    #####:  232:  GstWorkerClass *workerclass = GST_WORKER_CLASS (G_OBJECT_GET_CLASS (worker));
        -:  233:
    #####:  234:  GString *desc = NULL;
    #####:  235:  GstElement *pipeline = NULL;
    #####:  236:  GError *error = NULL;
    #####:  237:  GstParseContext *context = NULL;
    #####:  238:  gint parse_flags = GST_PARSE_FLAG_NONE;
    #####:  239:  parse_flags |= GST_PARSE_FLAG_FATAL_ERRORS;
        -:  240:
        -:  241:create_pipeline:
    #####:  242:  desc = workerclass->get_pipeline_string (worker);
    #####:  243:  context = gst_parse_context_new ();
        -:  244:
    #####:  245:  if (verbose) {
    #####:  246:    g_print ("%s: %s\n", worker->name, desc->str);
        -:  247:  }
        -:  248:
    #####:  249:  pipeline = (GstElement *) gst_parse_launch_full (desc->str, context,
        -:  250:      parse_flags, &error);
    #####:  251:  g_string_free (desc, TRUE);
        -:  252:
    #####:  253:  if (error == NULL) {
    #####:  254:    goto end;
        -:  255:  }
        -:  256:
    #####:  257:  if (pipeline) {
    #####:  258:    gchar *name = g_strdup_printf ("%s-pipeline", worker->name);
        -:  259:    //g_object_set (G_OBJECT (pipeline), "name", name, NULL);
    #####:  260:    gst_element_set_name (pipeline, name);
    #####:  261:    g_free (name);
        -:  262:  }
        -:  263:
    #####:  264:  if (g_error_matches (error, GST_PARSE_ERROR, GST_PARSE_ERROR_NO_SUCH_ELEMENT)) {
    #####:  265:    gchar **name = NULL;
    #####:  266:    gchar **names = gst_parse_context_get_missing_elements (context);
    #####:  267:    gboolean retry = workerclass->missing &&
    #####:  268:        (*workerclass->missing) (worker, names);
    #####:  269:    for (name = names; *name; ++name)
    #####:  270:      ERROR ("missing: %s", *name);
    #####:  271:    g_strfreev (names);
        -:  272:
    #####:  273:    if (retry) {
    #####:  274:      gst_parse_context_free (context);
    #####:  275:      context = NULL;
        -:  276:
    #####:  277:      g_assert (GST_OBJECT_REFCOUNT (pipeline) == 1);
    #####:  278:      gst_object_unref (pipeline);
    #####:  279:      pipeline = NULL;
        -:  280:
    #####:  281:      goto create_pipeline;
        -:  282:    }
        -:  283:  } else {
    #####:  284:    ERROR ("%s: pipeline parsing error: %s", worker->name, error->message);
        -:  285:  }
        -:  286:
    #####:  287:  if (pipeline) {
    #####:  288:    g_assert (GST_OBJECT_REFCOUNT (pipeline) == 1);
    #####:  289:    gst_object_unref (pipeline);
    #####:  290:    pipeline = NULL;
        -:  291:  }
        -:  292:
        -:  293:end:
    #####:  294:  gst_parse_context_free (context);
    #####:  295:  return pipeline;
        -:  296:}
        -:  297:
        -:  298:/**
        -:  299: * @brief Handler of the pipeline null message.
        -:  300: * @param worker The GstWorker instance.
        -:  301: * @memberof GstWorker
        -:  302: */
        -:  303:static GstWorkerNullReturn
    #####:  304:gst_worker_null (GstWorker * worker)
        -:  305:{
    #####:  306:  return (GST_IS_WORKER (worker) && worker->auto_replay) ?
        -:  307:      GST_WORKER_NR_END : GST_WORKER_NR_END;
        -:  308:}
        -:  309:
        -:  310:static gboolean gst_worker_prepare (GstWorker *);
        -:  311:
        -:  312:/**
        -:  313: * @brief Start the worker pipeline.
        -:  314: * @param worker The GstWorker instance.
        -:  315: * @memberof GstWorker
        -:  316: */
        -:  317:gboolean
    #####:  318:gst_worker_start (GstWorker * worker)
        -:  319:{
    #####:  320:  GstStateChangeReturn ret = GST_STATE_CHANGE_FAILURE;
        -:  321:
    #####:  322:  g_return_val_if_fail (GST_IS_WORKER (worker), FALSE);
        -:  323:
    #####:  324:  if (gst_worker_prepare (worker)) {
    #####:  325:    GST_WORKER_LOCK_PIPELINE (worker);
    #####:  326:    ret = gst_element_set_state (worker->pipeline, GST_STATE_READY);
    #####:  327:    GST_WORKER_UNLOCK_PIPELINE (worker);
        -:  328:  }
        -:  329:
    #####:  330:  return ret == GST_STATE_CHANGE_SUCCESS ? TRUE : FALSE;
        -:  331:}
        -:  332:
        -:  333:/**
        -:  334: * @brief Restart the worker pipeline.
        -:  335: * @param worker The GstWorker instance.
        -:  336: * @memberof GstWorker
        -:  337: */
        -:  338:static gboolean
    #####:  339:gst_worker_replay (GstWorker * worker)
        -:  340:{
    #####:  341:  GstStateChangeReturn ret = GST_STATE_CHANGE_FAILURE;
        -:  342:
    #####:  343:  g_return_val_if_fail (GST_IS_WORKER (worker), FALSE);
        -:  344:
    #####:  345:  GST_WORKER_LOCK_PIPELINE (worker);
        -:  346:
    #####:  347:  if (worker->pipeline) {
        -:  348:    GstState state;
        -:  349:
    #####:  350:    ret = gst_element_get_state (worker->pipeline, &state, NULL,
        -:  351:        GST_CLOCK_TIME_NONE);
        -:  352:
    #####:  353:    if (state != GST_STATE_PLAYING) {
    #####:  354:      ret = gst_element_set_state (worker->pipeline, GST_STATE_READY);
        -:  355:    }
        -:  356:  }
        -:  357:
    #####:  358:  GST_WORKER_UNLOCK_PIPELINE (worker);
        -:  359:
    #####:  360:  return ret == GST_STATE_CHANGE_SUCCESS ? TRUE : FALSE;
        -:  361:}
        -:  362:
        -:  363:static void gst_worker_state_ready_to_null (GstWorker *);
        -:  364:static gboolean
    #####:  365:gst_worker_state_ready_to_null_proxy (GstWorker * worker)
        -:  366:{
    #####:  367:  gst_worker_state_ready_to_null (worker);
    #####:  368:  return FALSE;
        -:  369:}
        -:  370:
        -:  371:/**
        -:  372: * @brief Stop the worker pipeline.
        -:  373: * @param worker The GstWorker instance.
        -:  374: * @param force Force stop if TRUE.
        -:  375: * @memberof GstWorker
        -:  376: */
        -:  377:gboolean
    #####:  378:gst_worker_stop_force (GstWorker * worker, gboolean force)
        -:  379:{
    #####:  380:  GstStateChangeReturn ret = GST_STATE_CHANGE_FAILURE;
        -:  381:
    #####:  382:  g_return_val_if_fail (GST_IS_WORKER (worker), FALSE);
        -:  383:
    #####:  384:  GST_WORKER_LOCK_PIPELINE (worker);
        -:  385:
    #####:  386:  if (worker->pipeline) {
        -:  387:#if 1
        -:  388:    GstState state;
        -:  389:
    #####:  390:    ret = gst_element_get_state (worker->pipeline, &state, NULL,
        -:  391:        GST_CLOCK_TIME_NONE);
        -:  392:
    #####:  393:    if (state == GST_STATE_PLAYING || force) {
    #####:  394:      ret = gst_element_set_state (worker->pipeline, GST_STATE_NULL);
        -:  395:
    #####:  396:      gst_bus_set_flushing (worker->bus, TRUE);
        -:  397:
    #####:  398:      g_timeout_add (5,
        -:  399:          (GSourceFunc) gst_worker_state_ready_to_null_proxy, worker);
        -:  400:    }
        -:  401:#else
        -:  402:    ret = gst_element_set_state (worker->pipeline, GST_STATE_NULL);
        -:  403:#endif
        -:  404:  }
        -:  405:
    #####:  406:  GST_WORKER_UNLOCK_PIPELINE (worker);
        -:  407:
    #####:  408:  return ret == GST_STATE_CHANGE_SUCCESS ? TRUE : FALSE;
        -:  409:}
        -:  410:
        -:  411:/**
        -:  412: * @memberof GstWorker
        -:  413: */
        -:  414:GstElement *
    #####:  415:gst_worker_get_element_unlocked (GstWorker * worker, const gchar * name)
        -:  416:{
    #####:  417:  g_return_val_if_fail (GST_IS_WORKER (worker), NULL);
        -:  418:
    #####:  419:  return gst_bin_get_by_name (GST_BIN (worker->pipeline), name);
        -:  420:}
        -:  421:
        -:  422:/**
        -:  423: */
        -:  424:GstElement *
    #####:  425:gst_worker_get_element (GstWorker * worker, const gchar * name)
        -:  426:{
    #####:  427:  GstElement *element = NULL;
        -:  428:
    #####:  429:  GST_WORKER_LOCK_PIPELINE (worker);
    #####:  430:  element = gst_worker_get_element_unlocked (worker, name);
    #####:  431:  GST_WORKER_UNLOCK_PIPELINE (worker);
    #####:  432:  return element;
        -:  433:}
        -:  434:
        -:  435:/*
        -:  436:static void
        -:  437:gst_worker_missing_plugin (GstWorker *worker, GstStructure *structure)
        -:  438:{
        -:  439:  GstWorkerClass *workerclass = GST_WORKER_CLASS (
        -:  440:      G_OBJECT_GET_CLASS (worker));
        -:  441:
        -:  442:  ERROR ("missing plugin");
        -:  443:
        -:  444:  if (workerclass->missing_plugin)
        -:  445:    (*workerclass->missing_plugin) (worker, structure);
        -:  446:}
        -:  447:*/
        -:  448:
        -:  449:static void
    #####:  450:gst_worker_handle_eos (GstWorker * worker)
        -:  451:{
    #####:  452:  gst_worker_stop (worker);
    #####:  453:}
        -:  454:
        -:  455:static void
    #####:  456:gst_worker_handle_error (GstWorker * worker, GError * error, const char *debug)
        -:  457:{
        -:  458:  //ERROR ("%s: %s", worker->name, error->message);
        -:  459:
    #####:  460:  if (error->domain == GST_CORE_ERROR) {
    #####:  461:    ERROR ("%s: (CORE: %d) %s", worker->name, error->code, error->message);
    #####:  462:    switch (error->code) {
        -:  463:      case GST_CORE_ERROR_MISSING_PLUGIN:
    #####:  464:        ERROR ("missing plugin..");
    #####:  465:        break;
        -:  466:      case GST_CORE_ERROR_NEGOTIATION:
    #####:  467:        ERROR ("%s: negotiation: %s", worker->name, error->message);
    #####:  468:        break;
        -:  469:    }
        -:  470:  }
        -:  471:
    #####:  472:  if (error->domain == GST_LIBRARY_ERROR) {
    #####:  473:    ERROR ("%s: (LIBRARY: %d) %s", worker->name, error->code, error->message);
        -:  474:  }
        -:  475:
    #####:  476:  if (error->domain == GST_RESOURCE_ERROR) {
    #####:  477:    ERROR ("%s: (RESOURCE: %d) %s", worker->name, error->code, error->message);
        -:  478:  }
        -:  479:
    #####:  480:  if (error->domain == GST_STREAM_ERROR) {
    #####:  481:    ERROR ("%s: (STREAM: %d) %s", worker->name, error->code, error->message);
        -:  482:  }
        -:  483:#if 0
        -:  484:  ERROR ("DEBUG INFO:\n%s\n", debug);
        -:  485:#endif
        -:  486:
        -:  487:#if 0
        -:  488:  gst_worker_stop (worker);
        -:  489:#endif
    #####:  490:}
        -:  491:
        -:  492:static void
    #####:  493:gst_worker_handle_warning (GstWorker * worker, GError * error,
        -:  494:    const char *debug)
        -:  495:{
    #####:  496:  WARN ("%s: %s", worker->name, error->message);
    #####:  497:}
        -:  498:
        -:  499:static void
    #####:  500:gst_worker_handle_info (GstWorker * worker, GError * error, const char *debug)
        -:  501:{
    #####:  502:  INFO ("%s: %s", worker->name, error->message);
    #####:  503:}
        -:  504:
        -:  505:static void
    #####:  506:gst_worker_state_null_to_ready (GstWorker * worker)
        -:  507:{
    #####:  508:  g_return_if_fail (GST_IS_WORKER (worker));
        -:  509:
    #####:  510:  gst_element_set_state (worker->pipeline, GST_STATE_PAUSED);
        -:  511:}
        -:  512:
        -:  513:static void
    #####:  514:gst_worker_state_ready_to_paused (GstWorker * worker)
        -:  515:{
    #####:  516:  g_return_if_fail (GST_IS_WORKER (worker));
        -:  517:
    #####:  518:  if (!worker->paused_for_buffering) {
    #####:  519:    gst_element_set_state (worker->pipeline, GST_STATE_PLAYING);
        -:  520:  }
        -:  521:}
        -:  522:
        -:  523:static void
    #####:  524:gst_worker_state_paused_to_playing (GstWorker * worker)
        -:  525:{
        -:  526:  GstWorkerClass *workerclass;
        -:  527:
    #####:  528:  g_return_if_fail (GST_IS_WORKER (worker));
        -:  529:
    #####:  530:  workerclass = GST_WORKER_CLASS (G_OBJECT_GET_CLASS (worker));
    #####:  531:  if (workerclass->alive) {
    #####:  532:    (*workerclass->alive) (worker);
        -:  533:  }
        -:  534:
    #####:  535:  g_signal_emit (worker, gst_worker_signals[SIGNAL_START_WORKER], 0);
        -:  536:}
        -:  537:
        -:  538:static void
    #####:  539:gst_worker_state_playing_to_paused (GstWorker * worker)
        -:  540:{
    #####:  541:}
        -:  542:
        -:  543:static void
    #####:  544:gst_worker_state_paused_to_ready (GstWorker * worker)
        -:  545:{
    #####:  546:}
        -:  547:
        -:  548:static void
    #####:  549:gst_worker_state_ready_to_null (GstWorker * worker)
        -:  550:{
        -:  551:  GstWorkerClass *workerclass;
    #####:  552:  GstWorkerNullReturn ret = GST_WORKER_NR_END;
        -:  553:
        -:  554:  //INFO ("%s", __FUNCTION__);
        -:  555:
    #####:  556:  g_return_if_fail (GST_IS_WORKER (worker));
        -:  557:
    #####:  558:  workerclass = GST_WORKER_CLASS (G_OBJECT_GET_CLASS (worker));
    #####:  559:  if (workerclass->null) {
    #####:  560:    switch ((ret = (*workerclass->null) (worker))) {
        -:  561:      case GST_WORKER_NR_REPLAY:
    #####:  562:        gst_worker_replay (worker);
    #####:  563:        break;
        -:  564:      case GST_WORKER_NR_END:
    #####:  565:        break;
        -:  566:    }
        -:  567:  }
        -:  568:
    #####:  569:  g_signal_emit (worker, gst_worker_signals[SIGNAL_WORKER_NULL], 0);
        -:  570:
    #####:  571:  if (ret == GST_WORKER_NR_END)
    #####:  572:    g_signal_emit (worker, gst_worker_signals[SIGNAL_END_WORKER], 0);
        -:  573:}
        -:  574:
        -:  575:static gboolean
    #####:  576:gst_worker_pipeline_state_changed (GstWorker * worker,
        -:  577:    GstStateChange statechange)
        -:  578:{
    #####:  579:  switch (statechange) {
        -:  580:    case GST_STATE_CHANGE_NULL_TO_READY:
    #####:  581:      gst_worker_state_null_to_ready (worker);
    #####:  582:      break;
        -:  583:    case GST_STATE_CHANGE_READY_TO_PAUSED:
    #####:  584:      gst_worker_state_ready_to_paused (worker);
    #####:  585:      break;
        -:  586:    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
    #####:  587:      gst_worker_state_paused_to_playing (worker);
    #####:  588:      break;
        -:  589:    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
    #####:  590:      gst_worker_state_playing_to_paused (worker);
    #####:  591:      break;
        -:  592:    case GST_STATE_CHANGE_PAUSED_TO_READY:
    #####:  593:      gst_worker_state_paused_to_ready (worker);
    #####:  594:      break;
        -:  595:    case GST_STATE_CHANGE_READY_TO_NULL:
        -:  596:#if 0
        -:  597:      gst_worker_state_ready_to_null (worker);
        -:  598:#endif
    #####:  599:      break;
        -:  600:    default:
    #####:  601:      return FALSE;
        -:  602:  }
    #####:  603:  return TRUE;
        -:  604:}
        -:  605:
        -:  606:static gboolean
    #####:  607:gst_worker_message (GstBus * bus, GstMessage * message, GstWorker * worker)
        -:  608:{
        -:  609:  GstWorkerClass *workerclass;
        -:  610:
        -:  611:  /* The event source should be removed if not worker ! */
    #####:  612:  g_return_val_if_fail (GST_IS_WORKER (worker), FALSE);
        -:  613:
    #####:  614:  workerclass = GST_WORKER_CLASS (G_OBJECT_GET_CLASS (worker));
        -:  615:
        -:  616:  //INFO ("%s: %s", __FUNCTION__, GST_MESSAGE_TYPE_NAME (message));
        -:  617:
    #####:  618:  switch (GST_MESSAGE_TYPE (message)) {
        -:  619:    case GST_MESSAGE_EOS:
    #####:  620:      gst_worker_handle_eos (worker);
    #####:  621:      break;
        -:  622:    case GST_MESSAGE_ERROR:
        -:  623:    {
    #####:  624:      GError *error = NULL;
        -:  625:      gchar *debug;
    #####:  626:      gst_message_parse_error (message, &error, &debug);
    #####:  627:      gst_worker_handle_error (worker, error, debug);
        -:  628:    }
    #####:  629:      break;
        -:  630:    case GST_MESSAGE_WARNING:
        -:  631:    {
    #####:  632:      GError *error = NULL;
        -:  633:      gchar *debug;
    #####:  634:      gst_message_parse_warning (message, &error, &debug);
    #####:  635:      gst_worker_handle_warning (worker, error, debug);
        -:  636:    }
    #####:  637:      break;
        -:  638:    case GST_MESSAGE_INFO:
        -:  639:    {
    #####:  640:      GError *error = NULL;
        -:  641:      gchar *debug;
    #####:  642:      gst_message_parse_info (message, &error, &debug);
    #####:  643:      gst_worker_handle_info (worker, error, debug);
        -:  644:    }
    #####:  645:      break;
        -:  646:    case GST_MESSAGE_TAG:
        -:  647:    {
        -:  648:      /*
        -:  649:         GstTagList *tag_list;
        -:  650:
        -:  651:         gst_message_parse_tag (message, &tag_list);
        -:  652:
        -:  653:         //if (verbose)
        -:  654:         //  g_print ("tag\n");
        -:  655:
        -:  656:         gst_tag_list_unref (tag_list);
        -:  657:       */
        -:  658:    }
    #####:  659:      break;
        -:  660:    case GST_MESSAGE_STATE_CHANGED:
        -:  661:    {
        -:  662:      gboolean ret;
        -:  663:      GstState oldstate, newstate, pending;
    #####:  664:      gst_message_parse_state_changed (message, &oldstate, &newstate, &pending);
    #####:  665:      if (GST_ELEMENT (message->src) == worker->pipeline) {
        -:  666:        /*
        -:  667:           if (verbose) {
        -:  668:           g_print ("%s: state change from %s to %s\n", worker->name,
        -:  669:           gst_element_state_get_name (oldstate),
        -:  670:           gst_element_state_get_name (newstate));
        -:  671:           }
        -:  672:         */
        -:  673:        /*
        -:  674:           INFO ("%s: %s to %s", worker->name,
        -:  675:           gst_element_state_get_name (oldstate),
        -:  676:           gst_element_state_get_name (newstate));
        -:  677:         */
        -:  678:
    #####:  679:        ret = gst_worker_pipeline_state_changed (worker,
    #####:  680:            GST_STATE_TRANSITION (oldstate, newstate));
        -:  681:
    #####:  682:        if (!ret /*&& verbose */ ) {
    #####:  683:          WARN ("%s: UNKNOWN state change from %s to %s\n",
        -:  684:              worker->name, gst_element_state_get_name (oldstate),
        -:  685:              gst_element_state_get_name (newstate));
        -:  686:        }
        -:  687:      }
        -:  688:    }
    #####:  689:      break;
        -:  690:    case GST_MESSAGE_BUFFERING:
        -:  691:    {
        -:  692:      int percent;
    #####:  693:      gst_message_parse_buffering (message, &percent);
        -:  694:      //g_print("buffering %d\n", percent);
    #####:  695:      if (!worker->paused_for_buffering && percent < 100) {
    #####:  696:        g_print ("pausing for buffing\n");
    #####:  697:        worker->paused_for_buffering = TRUE;
    #####:  698:        gst_element_set_state (worker->pipeline, GST_STATE_PAUSED);
    #####:  699:      } else if (worker->paused_for_buffering && percent == 100) {
    #####:  700:        g_print ("unpausing for buffing\n");
    #####:  701:        worker->paused_for_buffering = FALSE;
    #####:  702:        gst_element_set_state (worker->pipeline, GST_STATE_PLAYING);
        -:  703:      }
        -:  704:    }
    #####:  705:      break;
        -:  706:    case GST_MESSAGE_ELEMENT:
        -:  707:    case GST_MESSAGE_STATE_DIRTY:
        -:  708:    case GST_MESSAGE_CLOCK_PROVIDE:
        -:  709:    case GST_MESSAGE_CLOCK_LOST:
        -:  710:    case GST_MESSAGE_NEW_CLOCK:
        -:  711:    case GST_MESSAGE_STRUCTURE_CHANGE:
        -:  712:    case GST_MESSAGE_STREAM_STATUS:
    #####:  713:      break;
        -:  714:    case GST_MESSAGE_STEP_DONE:
        -:  715:    case GST_MESSAGE_APPLICATION:
        -:  716:    case GST_MESSAGE_SEGMENT_START:
        -:  717:    case GST_MESSAGE_SEGMENT_DONE:
        -:  718:    case GST_MESSAGE_LATENCY:
        -:  719:    case GST_MESSAGE_ASYNC_START:
        -:  720:    case GST_MESSAGE_ASYNC_DONE:
        -:  721:    case GST_MESSAGE_REQUEST_STATE:
        -:  722:    case GST_MESSAGE_STEP_START:
        -:  723:    case GST_MESSAGE_QOS:
        -:  724:    default:
    #####:  725:      if (verbose) {
        -:  726:        //g_print ("message: %s\n", GST_MESSAGE_TYPE_NAME (message));
        -:  727:      }
    #####:  728:      break;
        -:  729:  }
        -:  730:
    #####:  731:  return workerclass->message ? workerclass->message (worker, message) : TRUE;
        -:  732:}
        -:  733:
        -:  734:static gboolean
    #####:  735:gst_worker_prepare_unsafe (GstWorker * worker)
        -:  736:{
        -:  737:  GstWorkerClass *workerclass;
        -:  738:
    #####:  739:  g_return_val_if_fail (worker, FALSE);
        -:  740:
    #####:  741:  workerclass = GST_WORKER_CLASS (G_OBJECT_GET_CLASS (worker));
    #####:  742:  if (!workerclass->create_pipeline)
    #####:  743:    goto error_create_pipeline_not_installed;
        -:  744:
        -:  745:  //GST_WORKER_LOCK_PIPELINE (worker);
    #####:  746:  if (worker->pipeline)
    #####:  747:    goto end;
        -:  748:
    #####:  749:  worker->pipeline = workerclass->create_pipeline (worker);
    #####:  750:  if (!worker->pipeline)
    #####:  751:    goto error_create_pipeline;
        -:  752:
    #####:  753:  gst_pipeline_set_auto_flush_bus (GST_PIPELINE (worker->pipeline), FALSE);
        -:  754:
    #####:  755:  worker->bus = gst_pipeline_get_bus (GST_PIPELINE (worker->pipeline));
    #####:  756:  if (!worker->bus)
    #####:  757:    goto error_get_bus;
        -:  758:
    #####:  759:  worker->watch = gst_bus_add_watch (worker->bus,
        -:  760:      (GstBusFunc) gst_worker_message, worker);
        -:  761:
    #####:  762:  if (!worker->watch)
    #####:  763:    goto error_add_watch;
        -:  764:
    #####:  765:  if (workerclass->prepare && !workerclass->prepare (worker))
    #####:  766:    goto error_prepare;
        -:  767:
    #####:  768:  g_signal_emit (worker, gst_worker_signals[SIGNAL_PREPARE_WORKER], 0);
        -:  769:
        -:  770:end:
        -:  771:  //GST_WORKER_UNLOCK_PIPELINE (worker);
    #####:  772:  return TRUE;
        -:  773:
        -:  774:  /* Errors Handling */
        -:  775:
        -:  776:error_create_pipeline_not_installed:
        -:  777:  {
    #####:  778:    ERROR ("%s: create_pipeline was not installed", worker->name);
    #####:  779:    return FALSE;
        -:  780:  }
        -:  781:
        -:  782:error_create_pipeline:
        -:  783:  {
    #####:  784:    ERROR ("%s: failed to create new pipeline", worker->name);
        -:  785:    //GST_WORKER_UNLOCK_PIPELINE (worker);
    #####:  786:    return FALSE;
        -:  787:  }
        -:  788:
        -:  789:error_prepare:
        -:  790:  {
    #####:  791:    g_source_remove (worker->watch);
    #####:  792:    worker->watch = 0;
        -:  793:  error_add_watch:
    #####:  794:    g_assert (GST_OBJECT_REFCOUNT (worker->bus) == 1);
    #####:  795:    gst_object_unref (worker->bus);
    #####:  796:    worker->bus = NULL;
        -:  797:  error_get_bus:
    #####:  798:    g_assert (GST_OBJECT_REFCOUNT (worker->pipeline) == 1);
    #####:  799:    gst_object_unref (worker->pipeline);
    #####:  800:    worker->pipeline = NULL;
        -:  801:
    #####:  802:    ERROR ("%s: failed to prepare", worker->name);
        -:  803:    //GST_WORKER_UNLOCK_PIPELINE (worker);
    #####:  804:    return FALSE;
        -:  805:  }
        -:  806:}
        -:  807:
        -:  808:static gboolean
    #####:  809:gst_worker_prepare (GstWorker * worker)
        -:  810:{
    #####:  811:  gboolean ok = FALSE;
    #####:  812:  if (worker->pipeline == NULL) {
    #####:  813:    GST_WORKER_LOCK_PIPELINE (worker);
    #####:  814:    ok = gst_worker_prepare_unsafe (worker);
    #####:  815:    GST_WORKER_UNLOCK_PIPELINE (worker);
        -:  816:  } else {
    #####:  817:    ok = TRUE;
        -:  818:  }
    #####:  819:  return ok;
        -:  820:}
        -:  821:
        -:  822:static gboolean
    #####:  823:gst_worker_reset (GstWorker * worker)
        -:  824:{
    #####:  825:  gboolean ok = FALSE;
        -:  826:
    #####:  827:  g_return_val_if_fail (GST_IS_WORKER (worker), FALSE);
        -:  828:
        -:  829:  //INFO ("%s", __FUNCTION__);
        -:  830:
        -:  831:#if 1
    #####:  832:  if (worker) {
    #####:  833:    GST_WORKER_LOCK_PIPELINE (worker);
    #####:  834:    if (worker->pipeline) {
    #####:  835:      gst_element_set_state (worker->pipeline, GST_STATE_NULL);
        -:  836:    }
    #####:  837:    if (worker->bus) {
    #####:  838:      gst_bus_set_flushing (worker->bus, TRUE);
        -:  839:    }
        -:  840:
    #####:  841:    if (worker->watch) {
    #####:  842:      g_source_remove (worker->watch);
    #####:  843:      worker->watch = 0;
        -:  844:    }
    #####:  845:    if (worker->pipeline) {
    #####:  846:      if (1 < GST_OBJECT_REFCOUNT (worker->pipeline)) {
    #####:  847:        WARN ("possible pipeline leaks: %d",
        -:  848:            GST_OBJECT_REFCOUNT (worker->pipeline));
        -:  849:      }
    #####:  850:      gst_object_unref (worker->pipeline);
    #####:  851:      worker->pipeline = NULL;
        -:  852:    }
    #####:  853:    if (worker->bus) {
    #####:  854:      if (1 < GST_OBJECT_REFCOUNT (worker->bus)) {
    #####:  855:        WARN ("possible bus leaks: %d", GST_OBJECT_REFCOUNT (worker->bus));
        -:  856:      }
    #####:  857:      gst_object_unref (worker->bus);
    #####:  858:      worker->bus = NULL;
        -:  859:    }
    #####:  860:    ok = gst_worker_prepare_unsafe (worker);
    #####:  861:    GST_WORKER_UNLOCK_PIPELINE (worker);
        -:  862:  }
        -:  863:#else
        -:  864:  ok = TRUE;
        -:  865:#endif
        -:  866:
    #####:  867:  return ok;
        -:  868:}
        -:  869:
        -:  870:/**
        -:  871: * @brief Initialize GstWorkerClass.
        -:  872: * @param klass The instance of GstWorkerClass.
        -:  873: * @memberof GstWorkerClass
        -:  874: */
        -:  875:static void
    #####:  876:gst_worker_class_init (GstWorkerClass * klass)
        -:  877:{
    #####:  878:  GObjectClass *object_class = G_OBJECT_CLASS (klass);
        -:  879:
    #####:  880:  object_class->dispose = (GObjectFinalizeFunc) gst_worker_dispose;
    #####:  881:  object_class->finalize = (GObjectFinalizeFunc) gst_worker_finalize;
    #####:  882:  object_class->set_property = (GObjectSetPropertyFunc) gst_worker_set_property;
    #####:  883:  object_class->get_property = (GObjectGetPropertyFunc) gst_worker_get_property;
        -:  884:
    #####:  885:  gst_worker_signals[SIGNAL_PREPARE_WORKER] =
    #####:  886:      g_signal_new ("prepare-worker", G_TYPE_FROM_CLASS (klass),
        -:  887:      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstWorkerClass,
        -:  888:          prepare_worker), NULL,
        -:  889:      NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 0);
        -:  890:
    #####:  891:  gst_worker_signals[SIGNAL_START_WORKER] =
    #####:  892:      g_signal_new ("start-worker", G_TYPE_FROM_CLASS (klass),
        -:  893:      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstWorkerClass,
        -:  894:          start_worker), NULL,
        -:  895:      NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 0);
        -:  896:
    #####:  897:  gst_worker_signals[SIGNAL_END_WORKER] =
    #####:  898:      g_signal_new ("end-worker", G_TYPE_FROM_CLASS (klass),
        -:  899:      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstWorkerClass,
        -:  900:          end_worker), NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 0);
        -:  901:
    #####:  902:  gst_worker_signals[SIGNAL_WORKER_NULL] =
    #####:  903:      g_signal_new ("worker-null", G_TYPE_FROM_CLASS (klass),
        -:  904:      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstWorkerClass,
        -:  905:          worker_null), NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 0);
        -:  906:
    #####:  907:  g_object_class_install_property (object_class, PROP_NAME,
        -:  908:      g_param_spec_string ("name", "Name",
        -:  909:          "Name of the case", "", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
        -:  910:
    #####:  911:  klass->get_pipeline_string = gst_worker_get_pipeline_string;
    #####:  912:  klass->create_pipeline = gst_worker_create_pipeline;
    #####:  913:  klass->null = gst_worker_null;
    #####:  914:  klass->reset = gst_worker_reset;
    #####:  915:}
